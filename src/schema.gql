# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Player {
  id: ID!
  userId: String!
  gameId: String!
  points: Float!
  rewards: [PlayerReward!]!
}

type Game {
  id: ID!
  name: String!
  description: String
  gedilLayerId: String
  gedilLayerDescription: String
  startDate: Date
  endDate: Date
}

"""Date custom scalar type"""
scalar Date

type Challenge {
  id: ID!
  game: Game!
  parentChallenge: Challenge
  name: String!
  description: String
  difficulty: Difficulty!
  mode: Mode!
  modeParameters: [String!]!
  refs: [String!]!
  locked: Boolean!
  hidden: Boolean!
}

enum Difficulty {
  BEGINNER
  EASY
  AVERAGE
  HARD
  MASTER
}

enum Mode {
  NORMAL
  SHAPESHIFTER
  SHORTENING
  SPEEDUP
  HACK_IT
  TIME_BOMB
  DUEL
}

type RewardEntity {
  id: ID!
  game: Game
  parentChallenge: Challenge
  kind: RewardType!
  name: String!
  description: String
  image: String
  recurrent: Boolean!
  cost: Float
  amount: Float
  message: String
  challenges: [Challenge!]
  players: [PlayerReward!]!
}

enum RewardType {
  POINT
  BADGE
  VIRTUAL_ITEM
  COUPON
  REVEAL
  UNLOCK
  HINT
  MESSAGE
}

type PlayerReward {
  id: ID!
  players: Player!
  rewards: RewardEntity!
  count: Float!
}

type User {
  id: ID!
  name: String!
  username: String!
  email: Email!
  roles: [Role!]!
  photo: String
  telephone: String
  birthDate: Date
  createdAt: Date!
  updatedAt: Date!
  players: [PlayerReward!]!
}

"""Email custom scalar type"""
scalar Email

enum Role {
  USER
  ADMIN
}

type ListUsers {
  items: [User!]!
  total: Int!
}

type Action {
  type: Category!
  parameters: [String!]!
}

enum Category {
  GIVE
  TAKE
  UPDATE
}

type Condition {
  order: Float!
  leftEntity: String!
  leftProperty: String!
  comparingFunction: String!
  rightEntity: String!
  rightProperty: String!
}

type Criteria {
  conditions: [Condition!]!
  junctors: [Junctor!]!
}

enum Junctor {
  AND
  OR
}

type ScheduledHook {
  id: ID
  game: Game
  parentChallenge: Challenge
  criteria: Criteria
  actions: [Action!]
  recurrent: Boolean
  cron: String
  interval: Float
  active: Boolean
  lastRun: Date
}

type ActionHook {
  id: ID
  game: Game
  parentChallenge: Challenge
  trigger: TriggerEvent
  sourceId: String
  criteria: Criteria
  actions: [Action!]
  recurrent: Boolean
  active: Boolean
  lastRun: Date
}

enum TriggerEvent {
  SUBMISSION_EVALUATED
  SUBMISSION_RECEIVED
  SUBMISSION_ACCEPTED
  SUBMISSION_REJECTED
  CHALLENGE_COMPLETED
  CHALLENGE_FAILED
  REWARD_GRANTED
  PLAYER_UPDATED
  POINTS_UPDATED
  DUEL_INVITATION_RECEIVED
  DUEL_INITIATED
  DUEL_ACCEPTED
  DUEL_REJECTED
  DUEL_COMPLETED
}

type Badge {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  image: String
  recurrent: Boolean!
  cost: Float
  players: [PlayerReward!]!
}

type Coupon {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  image: String
  recurrent: Boolean!
  cost: Float
  amount: Float
  players: [PlayerReward!]!
}

type Hint {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  image: String
  recurrent: Boolean!
  cost: Float
  message: String
  challenges: [Challenge!]
  players: [PlayerReward!]!
}

type Message {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  image: String
  recurrent: Boolean!
  cost: Float
  message: String
  challenges: [Challenge!]
  players: [PlayerReward!]!
}

type Point {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  recurrent: Boolean!
  amount: Float
  players: [PlayerReward!]!
}

type VirtualItem {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  image: String
  recurrent: Boolean!
  cost: Float
  amount: Float
  players: [PlayerReward!]!
}

type Unlock {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  recurrent: Boolean!
  cost: Float
  challenges: [Challenge!]!
  players: [PlayerReward!]!
}

type Reveal {
  id: ID!
  game: Game
  parentChallenge: Challenge
  name: String!
  description: String
  recurrent: Boolean!
  cost: Float
  challenges: [Challenge!]!
  players: [PlayerReward!]!
}

type ChallengeEdge {
  """The node containing the Challenge"""
  node: Challenge!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

type PageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor

  """The cursor of the last returned record."""
  endCursor: ConnectionCursor
}

type ChallengeConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [ChallengeEdge!]!
}

type ChallengeStatus {
  studentId: String!
  challengeId: String!
  game: String!
  startedAt: Date
  endedAt: Date
  state: [State!]!
  openedAt: Date
}

enum State {
  LOCKED
  HIDDEN
  OPENED
  FAILED
  COMPLETED
  REJECTED
}

type Submission {
  id: ID!
  exerciseId: String!
  playerId: String!
  gameId: String!
  metrics: JSON
  result: Result
  grade: Float
  feedback: String
  submittedAt: Date!
  evaluatedAt: Date
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

enum Result {
  ACCEPTED
  REJECTED
}

type Query {
  user(id: String!): User!
  users(skip: Int = 0, take: Int = 50, ids: [ID!], name: String, order: String = "DESC", fieldSort: String = "updatedAt"): ListUsers!
  queryCheck: String!
  scheduledHooks: [ScheduledHook!]!
  actionHooks: [ActionHook!]!
  badges: [Badge!]!
  coupons: [Coupon!]!
  hints: [Hint!]!
  messages: [Message!]!
  points: [Point!]!
  virtualItems: [VirtualItem!]!
  unlocks: [Unlock!]!
  reveals: [Reveal!]!
  challenge(
    """The id of the record to find."""
    id: ID!
  ): Challenge
  challenges(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: ChallengeFilter = {}

    """Specify to sort results."""
    sorting: [ChallengeSort!] = []
  ): ChallengeConnection!
  game(id: String!): Game!
  get(gameId: String!, challengeId: String!, studentId: String!): ChallengeStatus!
  submission(submissionId: String!): Submission!
  submissions(exerciseId: String!): [Submission!]!
}

input CursorPaging {
  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

input ChallengeFilter {
  and: [ChallengeFilter!]
  or: [ChallengeFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  difficulty: DifficultyFilterComparison
  mode: ModeFilterComparison
  locked: BooleanFieldComparison
  hidden: BooleanFieldComparison
}

input IDFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ID
  neq: ID
  gt: ID
  gte: ID
  lt: ID
  lte: ID
  like: ID
  notLike: ID
  iLike: ID
  notILike: ID
  in: [ID!]
  notIn: [ID!]
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

input DifficultyFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: Difficulty
  neq: Difficulty
  gt: Difficulty
  gte: Difficulty
  lt: Difficulty
  lte: Difficulty
  like: Difficulty
  notLike: Difficulty
  iLike: Difficulty
  notILike: Difficulty
  in: [Difficulty!]
  notIn: [Difficulty!]
}

input ModeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: Mode
  neq: Mode
  gt: Mode
  gte: Mode
  lt: Mode
  lte: Mode
  like: Mode
  notLike: Mode
  iLike: Mode
  notILike: Mode
  in: [Mode!]
  notIn: [Mode!]
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

input ChallengeSort {
  field: ChallengeSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ChallengeSortFields {
  id
  name
  difficulty
  mode
  locked
  hidden
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

type Mutation {
  saveUser(id: ID, userInput: UserInput!): User!
  deleteUser(id: ID!): Boolean!
  login(login: String!, password: String!): User!
  signup(name: String!, username: String!, email: Email!, password: String!): User!
  mutationCheck: String!
  importGEdILArchive(name: String!, description: String, startDate: Date, endDate: Date, users: [String!], file: Upload!): Game!
  createSubmission(id: String!, gameId: String!, exerciseId: String!, playerId: String!, codeFile: String!): Submission!
}

input UserInput {
  name: String!
  username: String!
  email: Email!
  telephone: String
  birthDate: Date
  roles: [Role!] = [USER]
  password: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload
